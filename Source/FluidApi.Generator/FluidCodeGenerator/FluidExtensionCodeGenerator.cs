using Bars.Mvvm.FluidApi.Common;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Bars.Mvvm.FluidGenerator.Models;
using Microsoft.CodeAnalysis;
using Scriban;

namespace Bars.Mvvm.FluidApi.Generator;

/// <summary>
/// This generator is responsible for generating Fluid API for Bars MVVM ViewModels for easy configuration.
/// Example usage is
/// <code>
/// new BarButtonViewModel("key")
///     .WithLabel("Click!")
///     .WithCommand(new RoutedCommand())
///     .WithImages(new BarImageProvider(), "key");
/// </code>
/// </summary>
public class FluidExtensionCodeGenerator
{
    private static int _counter;

    private readonly Dictionary<Type, Template> _templateMapping = new()
    {
        {
            typeof(ObservableCollectionTemplateModel), Template.Parse(EmbeddedResource.GetContent("Templates/GetOnlyObservableCollection.fg-cs"))
        },
        {
            typeof(CommandWithParameterTemplateModel), Template.Parse(EmbeddedResource.GetContent("Templates/CommandWithParameter.fg-cs"))
        },
        {
            typeof(BooleanPropertyTemplateModel), Template.Parse(EmbeddedResource.GetContent("Templates/BooleanProperty.fg-cs"))
        },
        {
            typeof(PropertyTemplateModel), Template.Parse(EmbeddedResource.GetContent("Templates/DefaultProperty.fg-cs"))
        },
        {
            typeof(HasVariantImageTemplateModel), Template.Parse(EmbeddedResource.GetContent("Templates/HasVariantImages.fg-cs"))
        }
    };

    private readonly Dictionary<GeneratedType, Dictionary<string, string>> _customTemplates = new()
    {
        // Holds manually defined extension methods for specific ViewModels
        {
            GeneratedType.Wpf, new Dictionary<string, string>
            {
                { "BarComboBoxViewModel", EmbeddedResource.GetContent("CustomExtensions/Wpf/BarComboBoxViewModel.fg-cs") },
            }
        }
    };

    public string Generate(INamedTypeSymbol classSymbol, GeneratedType generatedFor)
    {
        var propertyTemplateModels = FluidExtensionPropertyParser.GetPropertyTemplateModels(classSymbol);
        if (propertyTemplateModels.Count == 0)
        {
            return string.Empty;
        }

        var nsName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;

        var sourceBuilder = new StringBuilder();
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine($"// generation counter: {Interlocked.Increment(ref _counter)}");
        if (generatedFor == GeneratedType.Avalonia)
        {
            sourceBuilder.AppendLine($"#nullable enable");
            sourceBuilder.AppendLine("using Avalonia.Controls.Templates;");
            sourceBuilder.AppendLine("using Avalonia.Input;");
            sourceBuilder.AppendLine("using Avalonia.Styling;");
        }
        else
        {
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine("using System.Windows.Input;");
        }

        sourceBuilder.AppendLine($"namespace {nsName};");
        sourceBuilder.AppendLine($"public static class {className}Extensions");
        sourceBuilder.AppendLineStartBracket(0);

        foreach (var propertyModel in propertyTemplateModels)
        {
            if (!_templateMapping.TryGetValue(propertyModel.GetType(), out Template template))
            {
                continue;
            }

            var output = template.Render(propertyModel, MemberRenamer);
            sourceBuilder.AppendLine(output);
        }

        if (generatedFor == GeneratedType.Wpf
            && classSymbol.AllInterfaces.Any(i => i.Name == "IHasVariantImages"))
        {
            var model = new HasVariantImageTemplateModel(classSymbol.Name);
            if (_templateMapping.TryGetValue(typeof(HasVariantImageTemplateModel), out Template variantTemplate))
            {
                var output = variantTemplate.Render(model, member => member.Name);
                sourceBuilder.AppendLine(output);
            }
        }

        // Append custom extensions if any
        AppendCustomExtensions(generatedFor, className, sourceBuilder);

        // Class end bracket
        sourceBuilder.AppendLineEndBracket(0);
        return sourceBuilder.ToString();
    }

    private void AppendCustomExtensions(GeneratedType generatedFor, string className, StringBuilder sourceBuilder)
    {

        // Custom templates for specific generated types
        if (!_customTemplates.TryGetValue(generatedFor, out var customTemplateDictionary))
        {
            return;
        }

        if (!customTemplateDictionary.TryGetValue(className, out string customTemplates))
        {
            return;
        }

        sourceBuilder.AppendLine(customTemplates);
    }

    private string MemberRenamer(MemberInfo member) => member.Name;
}
